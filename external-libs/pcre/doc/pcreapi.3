.TH PCRE 3
.SH NAME
PCRE - Perl-compatible regular expressions
.SH SYNOPSIS OF PCRE API
.rs
.sp
.B #include <pcre.h>
.PP
.SM
.br
.B pcre *pcre_compile(const char *\fIpattern\fR, int \fIoptions\fR,
.ti +5n
.B const char **\fIerrptr\fR, int *\fIerroffset\fR,
.ti +5n
.B const unsigned char *\fItableptr\fR);
.PP
.br
.B pcre_extra *pcre_study(const pcre *\fIcode\fR, int \fIoptions\fR,
.ti +5n
.B const char **\fIerrptr\fR);
.PP
.br
.B int pcre_exec(const pcre *\fIcode\fR, "const pcre_extra *\fIextra\fR,"
.ti +5n
.B "const char *\fIsubject\fR," int \fIlength\fR, int \fIstartoffset\fR,
.ti +5n
.B int \fIoptions\fR, int *\fIovector\fR, int \fIovecsize\fR);
.PP
.br
.B int pcre_copy_named_substring(const pcre *\fIcode\fR,
.ti +5n
.B const char *\fIsubject\fR, int *\fIovector\fR,
.ti +5n
.B int \fIstringcount\fR, const char *\fIstringname\fR,
.ti +5n
.B char *\fIbuffer\fR, int \fIbuffersize\fR);
.PP
.br
.B int pcre_copy_substring(const char *\fIsubject\fR, int *\fIovector\fR,
.ti +5n
.B int \fIstringcount\fR, int \fIstringnumber\fR, char *\fIbuffer\fR,
.ti +5n
.B int \fIbuffersize\fR);
.PP
.br
.B int pcre_get_named_substring(const pcre *\fIcode\fR,
.ti +5n
.B const char *\fIsubject\fR, int *\fIovector\fR,
.ti +5n
.B int \fIstringcount\fR, const char *\fIstringname\fR,
.ti +5n
.B const char **\fIstringptr\fR);
.PP
.br
.B int pcre_get_stringnumber(const pcre *\fIcode\fR,
.ti +5n
.B const char *\fIname\fR);
.PP
.br
.B int pcre_get_substring(const char *\fIsubject\fR, int *\fIovector\fR,
.ti +5n
.B int \fIstringcount\fR, int \fIstringnumber\fR,
.ti +5n
.B const char **\fIstringptr\fR);
.PP
.br
.B int pcre_get_substring_list(const char *\fIsubject\fR,
.ti +5n
.B int *\fIovector\fR, int \fIstringcount\fR, "const char ***\fIlistptr\fR);"
.PP
.br
.B void pcre_free_substring(const char *\fIstringptr\fR);
.PP
.br
.B void pcre_free_substring_list(const char **\fIstringptr\fR);
.PP
.br
.B const unsigned char *pcre_maketables(void);
.PP
.br
.B int pcre_fullinfo(const pcre *\fIcode\fR, "const pcre_extra *\fIextra\fR,"
.ti +5n
.B int \fIwhat\fR, void *\fIwhere\fR);
.PP
.br
.B int pcre_info(const pcre *\fIcode\fR, int *\fIoptptr\fR, int
.B *\fIfirstcharptr\fR);
.PP
.br
.B int pcre_config(int \fIwhat\fR, void *\fIwhere\fR);
.PP
.br
.B char *pcre_version(void);
.PP
.br
.B void *(*pcre_malloc)(size_t);
.PP
.br
.B void (*pcre_free)(void *);
.PP
.br
.B void *(*pcre_stack_malloc)(size_t);
.PP
.br
.B void (*pcre_stack_free)(void *);
.PP
.br
.B int (*pcre_callout)(pcre_callout_block *);

.SH PCRE API
.rs
.sp
PCRE has its own native API, which is described in this document. There is also
a set of wrapper functions that correspond to the POSIX regular expression API.
These are described in the \fBpcreposix\fR documentation.

The native API function prototypes are defined in the header file \fBpcre.h\fR,
and on Unix systems the library itself is called \fBlibpcre.a\fR, so can be
accessed by adding \fB-lpcre\fR to the command for linking an application which
calls it. The header file defines the macros PCRE_MAJOR and PCRE_MINOR to
contain the major and minor release numbers for the library. Applications can
use these to include support for different releases.

The functions \fBpcre_compile()\fR, \fBpcre_study()\fR, and \fBpcre_exec()\fR
are used for compiling and matching regular expressions. A sample program that
demonstrates the simplest way of using them is given in the file
\fIpcredemo.c\fR. The \fBpcresample\fR documentation describes how to run it.

There are convenience functions for extracting captured substrings from a
matched subject string. They are:

  \fBpcre_copy_substring()\fR
  \fBpcre_copy_named_substring()\fR
  \fBpcre_get_substring()\fR
  \fBpcre_get_named_substring()\fR
  \fBpcre_get_substring_list()\fR

\fBpcre_free_substring()\fR and \fBpcre_free_substring_list()\fR are also
provided, to free the memory used for extracted strings.

The function \fBpcre_maketables()\fR is used (optionally) to build a set of
character tables in the current locale for passing to \fBpcre_compile()\fR.

The function \fBpcre_fullinfo()\fR is used to find out information about a
compiled pattern; \fBpcre_info()\fR is an obsolete version which returns only
some of the available information, but is retained for backwards compatibility.
The function \fBpcre_version()\fR returns a pointer to a string containing the
version of PCRE and its date of release.

The global variables \fBpcre_malloc\fR and \fBpcre_free\fR initially contain
the entry points of the standard \fBmalloc()\fR and \fBfree()\fR functions
respectively. PCRE calls the memory management functions via these variables,
so a calling program can replace them if it wishes to intercept the calls. This
should be done before calling any PCRE functions.

The global variables \fBpcre_stack_malloc\fR and \fBpcre_stack_free\fR are also
indirections to memory management functions. These special functions are used
only when PCRE is compiled to use the heap for remembering data, instead of
recursive function calls. This is a non-standard way of building PCRE, for use
in environments that have limited stacks. Because of the greater use of memory
management, it runs more slowly. Separate functions are provided so that
special-purpose external code can be used for this case. When used, these
functions are always called in a stack-like manner (last obtained, first
freed), and always for memory blocks of the same size.

The global variable \fBpcre_callout\fR initially contains NULL. It can be set
by the caller to a "callout" function, which PCRE will then call at specified
points during a matching operation. Details are given in the \fBpcrecallout\fR
documentation.

.SH MULTITHREADING
.rs
.sp
The PCRE functions can be used in multi-threading applications, with the
proviso that the memory management functions pointed to by \fBpcre_malloc\fR,
\fBpcre_free\fR, \fBpcre_stack_malloc\fR, and \fBpcre_stack_free\fR, and the
callout function pointed to by \fBpcre_callout\fR, are shared by all threads.

The compiled form of a regular expression is not altered during matching, so
the same compiled pattern can safely be used by several threads at once.

.SH CHECKING BUILD-TIME OPTIONS
.rs
.sp
.B int pcre_config(int \fIwhat\fR, void *\fIwhere\fR);
.PP
The function \fBpcre_config()\fR makes it possible for a PCRE client to
discover which optional features have been compiled into the PCRE library. The
.\" HREF
\fBpcrebuild\fR
.\"
documentation has more details about these optional features.

The first argument for \fBpcre_config()\fR is an integer, specifying which
information is required; the second argument is a pointer to a variable into
which the information is placed. The following information is available:

  PCRE_CONFIG_UTF8

The output is an integer that is set to one if UTF-8 support is available;
otherwise it is set to zero.

  PCRE_CONFIG_NEWLINE

The output is an integer that is set to the value of the code that is used for
the newline character. It is either linefeed (10) or carriage return (13), and
should normally be the standard character for your operating system.

  PCRE_CONFIG_LINK_SIZE

The output is an integer that contains the number of bytes used for internal
linkage in compiled regular expressions. The value is 2, 3, or 4. Larger values
allow larger regular expressions to be compiled, at the expense of slower
matching. The default value of 2 is sufficient for all but the most massive
patterns, since it allows the compiled pattern to be up to 64K in size.

  PCRE_CONFIG_POSIX_MALLOC_THRESHOLD

The output is an integer that contains the threshold above which the POSIX
interface uses \fBmalloc()\fR for output vectors. Further details are given in
the \fBpcreposix\fR documentation.

  PCRE_CONFIG_MATCH_LIMIT

The output is an integer that gives the default limit for the number of
internal matching function calls in a \fBpcre_exec()\fR execution. Further
details are given with \fBpcre_exec()\fR below.

  PCRE_CONFIG_STACKRECURSE

The output is an integer that is set to one if internal recursion is
implemented by recursive function calls that use the stack to remember their
state. This is the usual way that PCRE is compiled. The output is zero if PCRE
was compiled to use blocks of data on the heap instead of recursive function
calls. In this case, \fBpcre_stack_malloc\fR and \fBpcre_stack_free\fR are
called to manage memory blocks on the heap, thus avoiding the use of the stack.

.SH COMPILING A PATTERN
.rs
.sp
.B pcre *pcre_compile(const char *\fIpattern\fR, int \fIoptions\fR,
.ti +5n
.B const char **\fIerrptr\fR, int *\fIerroffset\fR,
.ti +5n
.B const unsigned char *\fItableptr\fR);
.PP

The function \fBpcre_compile()\fR is called to compile a pattern into an
internal form. The pattern is a C string terminated by a binary zero, and
is passed in the argument \fIpattern\fR. A pointer to a single block of memory
that is obtained via \fBpcre_malloc\fR is returned. This contains the compiled
code and related data. The \fBpcre\fR type is defined for the returned block;
this is a typedef for a structure whose contents are not externally defined. It
is up to the caller to free the memory when it is no longer required.

Although the compiled code of a PCRE regex is relocatable, that is, it does not
depend on memory location, the complete \fBpcre\fR data block is not
fully relocatable, because it contains a copy of the \fItableptr\fR argument,
which is an address (see below).

The \fIoptions\fR argument contains independent bits that affect the
compilation. It should be zero if no options are required. Some of the options,
in particular, those that are compatible with Perl, can also be set and unset
from within the pattern (see the detailed description of regular expressions
in the \fBpcrepattern\fR documentation). For these options, the contents of the
\fIoptions\fR argument specifies their initial settings at the start of
compilation and execution. The PCRE_ANCHORED option can be set at the time of
matching as well as at compile time.

If \fIerrptr\fR is NULL, \fBpcre_compile()\fR returns NULL immediately.
Otherwise, if compilation of a pattern fails, \fBpcre_compile()\fR returns
NULL, and sets the variable pointed to by \fIerrptr\fR to point to a textual
error message. The offset from the start of the pattern to the character where
the error was discovered is placed in the variable pointed to by
\fIerroffset\fR, which must not be NULL. If it is, an immediate error is given.

If the final argument, \fItableptr\fR, is NULL, PCRE uses a default set of
character tables which are built when it is compiled, using the default C
locale. Otherwise, \fItableptr\fR must be the result of a call to
\fBpcre_maketables()\fR. See the section on locale support below.

This code fragment shows a typical straightforward call to \fBpcre_compile()\fR:

  pcre *re;
  const char *error;
  int erroffset;
  re = pcre_compile(
    "^A.*Z",          /* the pattern */
    0,                /* default options */
    &error,           /* for error message */
    &erroffset,       /* for error offset */
    NULL);            /* use default character tables */

The following option bits are defined:

  PCRE_ANCHORED

If this bit is set, the pattern is forced to be "anchored", that is, it is
constrained to match only at the first matching point in the string which is
being searched (the "subject string"). This effect can also be achieved by
appropriate constructs in the pattern itself, which is the only way to do it in
Perl.

  PCRE_CASELESS

If this bit is set, letters in the pattern match both upper and lower case
letters. It is equivalent to Perl's /i option, and it can be changed within a
pattern by a (?i) option setting.

  PCRE_DOLLAR_ENDONLY

If this bit is set, a dollar metacharacter in the pattern matches only at the
end of the subject string. Without this option, a dollar also matches
immediately before the final character if it is a newline (but not before any
other newlines). The PCRE_DOLLAR_ENDONLY option is ignored if PCRE_MULTILINE is
set. There is no equivalent to this option in Perl, and no way to set it within
a pattern.

  PCRE_DOTALL

If this bit is set, a dot metacharater in the pattern matches all characters,
including newlines. Without it, newlines are excluded. This option is
equivalent to Perl's /s option, and it can be changed within a pattern by a
(?s) option setting. A negative class such as [^a] always matches a newline
character, independent of the setting of this option.

  PCRE_EXTENDED

If this bit is set, whitespace data characters in the pattern are totally
ignored except when escaped or inside a character class. Whitespace does not
include the VT character (code 11). In addition, characters between an
unescaped # outside a character class and the next newline character,
inclusive, are also ignored. This is equivalent to Perl's /x option, and it can
be changed within a pattern by a (?x) option setting.

This option makes it possible to include comments inside complicated patterns.
Note, however, that this applies only to data characters. Whitespace characters
may never appear within special character sequences in a pattern, for example
within the sequence (?( which introduces a conditional subpattern.

  PCRE_EXTRA

This option was invented in order to turn on additional functionality of PCRE
that is incompatible with Perl, but it is currently of very little use. When
set, any backslash in a pattern that is followed by a letter that has no
special meaning causes an error, thus reserving these combinations for future
expansion. By default, as in Perl, a backslash followed by a letter with no
special meaning is treated as a literal. There are at present no other features
controlled by this option. It can also be set by a (?X) option setting within a
pattern.

  PCRE_MULTILINE

By default, PCRE treats the subject string as consisting of a single "line" of
characters (even if it actually contains several newlines). The "start of line"
metacharacter (^) matches only at the start of the string, while the "end of
line" metacharacter ($) matches only at the end of the string, or before a
terminating newline (unless PCRE_DOLLAR_ENDONLY is set). This is the same as
Perl.

When PCRE_MULTILINE it is set, the "start of line" and "end of line" constructs
match immediately following or immediately before any newline in the subject
string, respectively, as well as at the very start and end. This is equivalent
to Perl's /m option, and it can be changed within a pattern by a (?m) option
setting. If there are no "\\n" characters in a subject string, or no
occurrences of ^ or $ in a pattern, setting PCRE_MULTILINE has no effect.

  PCRE_NO_AUTO_CAPTURE

If this option is set, it disables the use of numbered capturing parentheses in
the pattern. Any opening parenthesis that is not followed by ? behaves as if it
were followed by ?: but named parentheses can still be used for capturing (and
they acquire numbers in the usual way). There is no equivalent of this option
in Perl.

  PCRE_UNGREEDY

This option inverts the "greediness" of the quantifiers so that they are not
greedy by default, but become greedy if followed by "?". It is not compatible
with Perl. It can also be set by a (?U) option setting within the pattern.

  PCRE_UTF8

This option causes PCRE to regard both the pattern and the subject as strings
of UTF-8 characters instead of single-byte character strings. However, it is
available only if PCRE has been built to include UTF-8 support. If not, the use
of this option provokes an error. Details of how this option changes the
behaviour of PCRE are given in the
.\" HTML <a href="pcre.html#utf8support">
.\" </a>
section on UTF-8 support
.\"
in the main
.\" HREF
\fBpcre\fR
.\"
page.

  PCRE_NO_UTF8_CHECK

When PCRE_UTF8 is set, the validity of the pattern as a UTF-8 string is
automatically checked. If an invalid UTF-8 sequence of bytes is found,
\fBpcre_compile()\fR returns an error. If you already know that your pattern is
valid, and you want to skip this check for performance reasons, you can set the
PCRE_NO_UTF8_CHECK option. When it is set, the effect of passing an invalid
UTF-8 string as a pattern is undefined. It may cause your program to crash.
Note that there is a similar option for suppressing the checking of subject
strings passed to \fBpcre_exec()\fR.


.SH STUDYING A PATTERN
.rs
.sp
.B pcre_extra *pcre_study(const pcre *\fIcode\fR, int \fIoptions\fR,
.ti +5n
.B const char **\fIerrptr\fR);
.PP
When a pattern is going to be used several times, it is worth spending more
time analyzing it in order to speed up the time taken for matching. The
function \fBpcre_study()\fR takes a pointer to a compiled pattern as its first
argument. If studing the pattern produces additional information that will help
speed up matching, \fBpcre_study()\fR returns a pointer to a \fBpcre_extra\fR
block, in which the \fIstudy_data\fR field points to the results of the study.

The returned value from a \fBpcre_study()\fR can be passed directly to
\fBpcre_exec()\fR. However, the \fBpcre_extra\fR block also contains other
fields that can be set by the caller before the block is passed; these are
described below. If studying the pattern does not produce any additional
information, \fBpcre_study()\fR returns NULL. In that circumstance, if the
calling program wants to pass some of the other fields to \fBpcre_exec()\fR, it
must set up its own \fBpcre_extra\fR block.

The second argument contains option bits. At present, no options are defined
for \fBpcre_study()\fR, and this argument should always be zero.

The third argument for \fBpcre_study()\fR is a pointer for an error message. If
studying succeeds (even if no data is returned), the variable it points to is
set to NULL. Otherwise it points to a textual error message. You should
therefore test the error pointer for NULL after calling \fBpcre_study()\fR, to
be sure that it has run successfully.

This is a typical call to \fBpcre_study\fR():

  pcre_extra *pe;
  pe = pcre_study(
    re,             /* result of pcre_compile() */
    0,              /* no options exist */
    &error);        /* set to NULL or points to a message */

At present, studying a pattern is useful only for non-anchored patterns that do
not have a single fixed starting character. A bitmap of possible starting
characters is created.

.\" HTML <a name="localesupport"></a>
.SH LOCALE SUPPORT
.rs
.sp
PCRE handles caseless matching, and determines whether characters are letters,
digits, or whatever, by reference to a set of tables. When running in UTF-8
mode, this applies only to characters with codes less than 256. The library
contains a default set of tables that is created in the default C locale when
PCRE is compiled. This is used when the final argument of \fBpcre_compile()\fR
is NULL, and is sufficient for many applications.

An alternative set of tables can, however, be supplied. Such tables are built
by calling the \fBpcre_maketables()\fR function, which has no arguments, in the
relevant locale. The result can then be passed to \fBpcre_compile()\fR as often
as necessary. For example, to build and use tables that are appropriate for the
French locale (where accented characters with codes greater than 128 are
treated as letters), the following code could be used:

  setlocale(LC_CTYPE, "fr");
  tables = pcre_maketables();
  re = pcre_compile(..., tables);

The tables are built in memory that is obtained via \fBpcre_malloc\fR. The
pointer that is passed to \fBpcre_compile\fR is saved with the compiled
pattern, and the same tables are used via this pointer by \fBpcre_study()\fR
and \fBpcre_exec()\fR. Thus, for any single pattern, compilation, studying and
matching all happen in the same locale, but different patterns can be compiled
in different locales. It is the caller's responsibility to ensure that the
memory containing the tables remains available for as long as it is needed.

.SH INFORMATION ABOUT A PATTERN
.rs
.sp
.B int pcre_fullinfo(const pcre *\fIcode\fR, "const pcre_extra *\fIextra\fR,"
.ti +5n
.B int \fIwhat\fR, void *\fIwhere\fR);
.PP
The \fBpcre_fullinfo()\fR function returns information about a compiled
pattern. It replaces the obsolete \fBpcre_info()\fR function, which is
nevertheless retained for backwards compability (and is documented below).

The first argument for \fBpcre_fullinfo()\fR is a pointer to the compiled
pattern. The second argument is the result of \fBpcre_study()\fR, or NULL if
the pattern was not studied. The third argument specifies which piece of
information is required, and the fourth argument is a pointer to a variable
to receive the data. The yield of the function is zero for success, or one of
the following negative numbers:

  PCRE_ERROR_NULL       the argument \fIcode\fR was NULL
                        the argument \fIwhere\fR was NULL
  PCRE_ERROR_BADMAGIC   the "magic number" was not found
  PCRE_ERROR_BADOPTION  the value of \fIwhat\fR was invalid

Here is a typical call of \fBpcre_fullinfo()\fR, to obtain the length of the
compiled pattern:

  int rc;
  unsigned long int length;
  rc = pcre_fullinfo(
    re,               /* result of pcre_compile() */
    pe,               /* result of pcre_study(), or NULL */
    PCRE_INFO_SIZE,   /* what is required */
    &length);         /* where to put the data */

The possible values for the third argument are defined in \fBpcre.h\fR, and are
as follows:

  PCRE_INFO_BACKREFMAX

Return the number of the highest back reference in the pattern. The fourth
argument should point to an \fBint\fR variable. Zero is returned if there are
no back references.

  PCRE_INFO_CAPTURECOUNT

Return the number of capturing subpatterns in the pattern. The fourth argument
should point to an \fbint\fR variable.

  PCRE_INFO_FIRSTBYTE

Return information about the first byte of any matched string, for a
non-anchored pattern. (This option used to be called PCRE_INFO_FIRSTCHAR; the
old name is still recognized for backwards compatibility.)

If there is a fixed first byte, e.g. from a pattern such as (cat|cow|coyote),
it is returned in the integer pointed to by \fIwhere\fR. Otherwise, if either

(a) the pattern was compiled with the PCRE_MULTILINE option, and every branch
starts with "^", or

(b) every branch of the pattern starts with ".*" and PCRE_DOTALL is not set
(if it were set, the pattern would be anchored),

-1 is returned, indicating that the pattern matches only at the start of a
subject string or after any newline within the string. Otherwise -2 is
returned. For anchored patterns, -2 is returned.

  PCRE_INFO_FIRSTTABLE

If the pattern was studied, and this resulted in the construction of a 256-bit
table indicating a fixed set of bytes for the first byte in any matching
string, a pointer to the table is returned. Otherwise NULL is returned. The
fourth argument should point to an \fBunsigned char *\fR variable.

  PCRE_INFO_LASTLITERAL

Return the value of the rightmost literal byte that must exist in any matched
string, other than at its start, if such a byte has been recorded. The fourth
argument should point to an \fBint\fR variable. If there is no such byte, -1 is
returned. For anchored patterns, a last literal byte is recorded only if it
follows something of variable length. For example, for the pattern
/^a\\d+z\\d+/ the returned value is "z", but for /^a\\dz\\d/ the returned value
is -1.

  PCRE_INFO_NAMECOUNT
  PCRE_INFO_NAMEENTRYSIZE
  PCRE_INFO_NAMETABLE

PCRE supports the use of named as well as numbered capturing parentheses. The
names are just an additional way of identifying the parentheses, which still
acquire a number. A caller that wants to extract data from a named subpattern
must convert the name to a number in order to access the correct pointers in
the output vector (described with \fBpcre_exec()\fR below). In order to do
this, it must first use these three values to obtain the name-to-number mapping
table for the pattern.

The map consists of a number of fixed-size entries. PCRE_INFO_NAMECOUNT gives
the number of entries, and PCRE_INFO_NAMEENTRYSIZE gives the size of each
entry; both of these return an \fBint\fR value. The entry size depends on the
length of the longest name. PCRE_INFO_NAMETABLE returns a pointer to the first
entry of the table (a pointer to \fBchar\fR). The first two bytes of each entry
are the number of the capturing parenthesis, most significant byte first. The
rest of the entry is the corresponding name, zero terminated. The names are in
alphabetical order. For example, consider the following pattern (assume
PCRE_EXTENDED is set, so white space - including newlines - is ignored):

  (?P<date> (?P<year>(\\d\\d)?\\d\\d) -
  (?P<month>\\d\\d) - (?P<day>\\d\\d) )

There are four named subpatterns, so the table has four entries, and each entry
in the table is eight bytes long. The table is as follows, with non-printing
bytes shows in hex, and undefined bytes shown as ??:

  00 01 d  a  t  e  00 ??
  00 05 d  a  y  00 ?? ??
  00 04 m  o  n  t  h  00
  00 02 y  e  a  r  00 ??

When writing code to extract data from named subpatterns, remember that the
length of each entry may be different for each compiled pattern.

  PCRE_INFO_OPTIONS

Return a copy of the options with which the pattern was compiled. The fourth
argument should point to an \fBunsigned long int\fR variable. These option bits
are those specified in the call to \fBpcre_compile()\fR, modified by any
top-level option settings within the pattern itself.

A pattern is automatically anchored by PCRE if all of its top-level
alternatives begin with one of the following:

  ^     unless PCRE_MULTILINE is set
  \\A    always
  \\G    always
  .*    if PCRE_DOTALL is set and there are no back
          references to the subpattern in which .* appears

For such patterns, the PCRE_ANCHORED bit is set in the options returned by
\fBpcre_fullinfo()\fR.

  PCRE_INFO_SIZE

Return the size of the compiled pattern, that is, the value that was passed as
the argument to \fBpcre_malloc()\fR when PCRE was getting memory in which to
place the compiled data. The fourth argument should point to a \fBsize_t\fR
variable.

  PCRE_INFO_STUDYSIZE

Returns the size of the data block pointed to by the \fIstudy_data\fR field in
a \fBpcre_extra\fR block. That is, it is the value that was passed to
\fBpcre_malloc()\fR when PCRE was getting memory into which to place the data
created by \fBpcre_study()\fR. The fourth argument should point to a
\fBsize_t\fR variable.

.SH OBSOLETE INFO FUNCTION
.rs
.sp
.B int pcre_info(const pcre *\fIcode\fR, int *\fIoptptr\fR, int
.B *\fIfirstcharptr\fR);
.PP
The \fBpcre_info()\fR function is now obsolete because its interface is too
restrictive to return all the available data about a compiled pattern. New
programs should use \fBpcre_fullinfo()\fR instead. The yield of
\fBpcre_info()\fR is the number of capturing subpatterns, or one of the
following negative numbers:

  PCRE_ERROR_NULL       the argument \fIcode\fR was NULL
  PCRE_ERROR_BADMAGIC   the "magic number" was not found

If the \fIoptptr\fR argument is not NULL, a copy of the options with which the
pattern was compiled is placed in the integer it points to (see
PCRE_INFO_OPTIONS above).

If the pattern is not anchored and the \fIfirstcharptr\fR argument is not NULL,
it is used to pass back information about the first character of any matched
string (see PCRE_INFO_FIRSTBYTE above).

.SH MATCHING A PATTERN
.rs
.sp
.B int pcre_exec(const pcre *\fIcode\fR, "const pcre_extra *\fIextra\fR,"
.ti +5n
.B "const char *\fIsubject\fR," int \fIlength\fR, int \fIstartoffset\fR,
.ti +5n
.B int \fIoptions\fR, int *\fIovector\fR, int \fIovecsize\fR);
.PP
The function \fBpcre_exec()\fR is called to match a subject string against a
pre-compiled pattern, which is passed in the \fIcode\fR argument. If the
pattern has been studied, the result of the study should be passed in the
\fIextra\fR argument.

Here is an example of a simple call to \fBpcre_exec()\fR:

  int rc;
  int ovector[30];
  rc = pcre_exec(
    re,             /* result of pcre_compile() */
    NULL,           /* we didn't study the pattern */
    "some string",  /* the subject string */
    11,             /* the length of the subject string */
    0,              /* start at offset 0 in the subject */
    0,              /* default options */
    ovector,        /* vector for substring information */
    30);            /* number of elements in the vector */

If the \fIextra\fR argument is not NULL, it must point to a \fBpcre_extra\fR
data block. The \fBpcre_study()\fR function returns such a block (when it
doesn't return NULL), but you can also create one for yourself, and pass
additional information in it. The fields in the block are as follows:

  unsigned long int \fIflags\fR;
  void *\fIstudy_data\fR;
  unsigned long int \fImatch_limit\fR;
  void *\fIcallout_data\fR;

The \fIflags\fR field is a bitmap that specifies which of the other fields
are set. The flag bits are:

  PCRE_EXTRA_STUDY_DATA
  PCRE_EXTRA_MATCH_LIMIT
  PCRE_EXTRA_CALLOUT_DATA

Other flag bits should be set to zero. The \fIstudy_data\fR field is set in the
\fBpcre_extra\fR block that is returned by \fBpcre_study()\fR, together with
the appropriate flag bit. You should not set this yourself, but you can add to
the block by setting the other fields.

The \fImatch_limit\fR field provides a means of preventing PCRE from using up a
vast amount of resources when running patterns that are not going to match,
but which have a very large number of possibilities in their search trees. The
classic example is the use of nested unlimited repeats. Internally, PCRE uses a
function called \fBmatch()\fR which it calls repeatedly (sometimes
recursively). The limit is imposed on the number of times this function is
called during a match, which has the effect of limiting the amount of recursion
and backtracking that can take place. For patterns that are not anchored, the
count starts from zero for each position in the subject string.

The default limit for the library can be set when PCRE is built; the default
default is 10 million, which handles all but the most extreme cases. You can
reduce the default by suppling \fBpcre_exec()\fR with a \fRpcre_extra\fR block
in which \fImatch_limit\fR is set to a smaller value, and
PCRE_EXTRA_MATCH_LIMIT is set in the \fIflags\fR field. If the limit is
exceeded, \fBpcre_exec()\fR returns PCRE_ERROR_MATCHLIMIT.

The \fIpcre_callout\fR field is used in conjunction with the "callout" feature,
which is described in the \fBpcrecallout\fR documentation.

The PCRE_ANCHORED option can be passed in the \fIoptions\fR argument, whose
unused bits must be zero. This limits \fBpcre_exec()\fR to matching at the
first matching position. However, if a pattern was compiled with PCRE_ANCHORED,
or turned out to be anchored by virtue of its contents, it cannot be made
unachored at matching time.

When PCRE_UTF8 was set at compile time, the validity of the subject as a UTF-8
string is automatically checked, and the value of \fIstartoffset\fR is also
checked to ensure that it points to the start of a UTF-8 character. If an
invalid UTF-8 sequence of bytes is found, \fBpcre_exec()\fR returns the error
PCRE_ERROR_BADUTF8. If \fIstartoffset\fR contains an invalid value,
PCRE_ERROR_BADUTF8_OFFSET is returned.

If you already know that your subject is valid, and you want to skip these
checks for performance reasons, you can set the PCRE_NO_UTF8_CHECK option when
calling \fBpcre_exec()\fR. You might want to do this for the second and
subsequent calls to \fBpcre_exec()\fR if you are making repeated calls to find
all the matches in a single subject string. However, you should be sure that
the value of \fIstartoffset\fR points to the start of a UTF-8 character. When
PCRE_NO_UTF8_CHECK is set, the effect of passing an invalid UTF-8 string as a
subject, or a value of \fIstartoffset\fR that does not point to the start of a
UTF-8 character, is undefined. Your program may crash.

There are also three further options that can be set only at matching time:

  PCRE_NOTBOL

The first character of the string is not the beginning of a line, so the
circumflex metacharacter should not match before it. Setting this without
PCRE_MULTILINE (at compile time) causes circumflex never to match.

  PCRE_NOTEOL

The end of the string is not the end of a line, so the dollar metacharacter
should not match it nor (except in multiline mode) a newline immediately before
it. Setting this without PCRE_MULTILINE (at compile time) causes dollar never
to match.

  PCRE_NOTEMPTY

An empty string is not considered to be a valid match if this option is set. If
there are alternatives in the pattern, they are tried. If all the alternatives
match the empty string, the entire match fails. For example, if the pattern

  a?b?

is applied to a string not beginning with "a" or "b", it matches the empty
string at the start of the subject. With PCRE_NOTEMPTY set, this match is not
valid, so PCRE searches further into the string for occurrences of "a" or "b".

Perl has no direct equivalent of PCRE_NOTEMPTY, but it does make a special case
of a pattern match of the empty string within its \fBsplit()\fR function, and
when using the /g modifier. It is possible to emulate Perl's behaviour after
matching a null string by first trying the match again at the same offset with
PCRE_NOTEMPTY set, and then if that fails by advancing the starting offset (see
below) and trying an ordinary match again.

The subject string is passed to \fBpcre_exec()\fR as a pointer in
\fIsubject\fR, a length in \fIlength\fR, and a starting byte offset in
\fIstartoffset\fR. Unlike the pattern string, the subject may contain binary
zero bytes. When the starting offset is zero, the search for a match starts at
the beginning of the subject, and this is by far the most common case.

If the pattern was compiled with the PCRE_UTF8 option, the subject must be a
sequence of bytes that is a valid UTF-8 string, and the starting offset must
point to the beginning of a UTF-8 character. If an invalid UTF-8 string or
offset is passed, an error (either PCRE_ERROR_BADUTF8 or
PCRE_ERROR_BADUTF8_OFFSET) is returned, unless the option PCRE_NO_UTF8_CHECK is
set, in which case PCRE's behaviour is not defined.

A non-zero starting offset is useful when searching for another match in the
same subject by calling \fBpcre_exec()\fR again after a previous success.
Setting \fIstartoffset\fR differs from just passing over a shortened string and
setting PCRE_NOTBOL in the case of a pattern that begins with any kind of
lookbehind. For example, consider the pattern

  \\Biss\\B

which finds occurrences of "iss" in the middle of words. (\\B matches only if
the current position in the subject is not a word boundary.) When applied to
the string "Mississipi" the first call to \fBpcre_exec()\fR finds the first
occurrence. If \fBpcre_exec()\fR is called again with just the remainder of the
subject, namely "issipi", it does not match, because \\B is always false at the
start of the subject, which is deemed to be a word boundary. However, if
\fBpcre_exec()\fR is passed the entire string again, but with \fIstartoffset\fR
set to 4, it finds the second occurrence of "iss" because it is able to look
behind the starting point to discover that it is preceded by a letter.

If a non-zero starting offset is passed when the pattern is anchored, one
attempt to match at the given offset is tried. This can only succeed if the
pattern does not require the match to be at the start of the subject.

In general, a pattern matches a certain portion of the subject, and in
addition, further substrings from the subject may be picked out by parts of the
pattern. Following the usage in Jeffrey Friedl's book, this is called
"capturing" in what follows, and the phrase "capturing subpattern" is used for
a fragment of a pattern that picks out a substring. PCRE supports several other
kinds of parenthesized subpattern that do not cause substrings to be captured.

Captured substrings are returned to the caller via a vector of integer offsets
whose address is passed in \fIovector\fR. The number of elements in the vector
is passed in \fIovecsize\fR. The first two-thirds of the vector is used to pass
back captured substrings, each substring using a pair of integers. The
remaining third of the vector is used as workspace by \fBpcre_exec()\fR while
matching capturing subpatterns, and is not available for passing back
information. The length passed in \fIovecsize\fR should always be a multiple of
three. If it is not, it is rounded down.

When a match has been successful, information about captured substrings is
returned in pairs of integers, starting at the beginning of \fIovector\fR, and
continuing up to two-thirds of its length at the most. The first element of a
pair is set to the offset of the first character in a substring, and the second
is set to the offset of the first character after the end of a substring. The
first pair, \fIovector[0]\fR and \fIovector[1]\fR, identify the portion of the
subject string matched by the entire pattern. The next pair is used for the
first capturing subpattern, and so on. The value returned by \fBpcre_exec()\fR
is the number of pairs that have been set. If there are no capturing
subpatterns, the return value from a successful match is 1, indicating that
just the first pair of offsets has been set.

Some convenience functions are provided for extracting the captured substrings
as separate strings. These are described in the following section.

It is possible for an capturing subpattern number \fIn+1\fR to match some
part of the subject when subpattern \fIn\fR has not been used at all. For
example, if the string "abc" is matched against the pattern (a|(z))(bc)
subpatterns 1 and 3 are matched, but 2 is not. When this happens, both offset
values corresponding to the unused subpattern are set to -1.

If a capturing subpattern is matched repeatedly, it is the last portion of the
string that it matched that gets returned.

If the vector is too small to hold all the captured substrings, it is used as
far as possible (up to two-thirds of its length), and the function returns a
value of zero. In particular, if the substring offsets are not of interest,
\fBpcre_exec()\fR may be called with \fIovector\fR passed as NULL and
\fIovecsize\fR as zero. However, if the pattern contains back references and
the \fIovector\fR isn't big enough to remember the related substrings, PCRE has
to get additional memory for use during matching. Thus it is usually advisable
to supply an \fIovector\fR.

Note that \fBpcre_info()\fR can be used to find out how many capturing
subpatterns there are in a compiled pattern. The smallest size for
\fIovector\fR that will allow for \fIn\fR captured substrings, in addition to
the offsets of the substring matched by the whole pattern, is (\fIn\fR+1)*3.

If \fBpcre_exec()\fR fails, it returns a negative number. The following are
defined in the header file:

  PCRE_ERROR_NOMATCH        (-1)

The subject string did not match the pattern.

  PCRE_ERROR_NULL           (-2)

Either \fIcode\fR or \fIsubject\fR was passed as NULL, or \fIovector\fR was
NULL and \fIovecsize\fR was not zero.

  PCRE_ERROR_BADOPTION      (-3)

An unrecognized bit was set in the \fIoptions\fR argument.

  PCRE_ERROR_BADMAGIC       (-4)

PCRE stores a 4-byte "magic number" at the start of the compiled code, to catch
the case when it is passed a junk pointer. This is the error it gives when the
magic number isn't present.

  PCRE_ERROR_UNKNOWN_NODE   (-5)

While running the pattern match, an unknown item was encountered in the
compiled pattern. This error could be caused by a bug in PCRE or by overwriting
of the compiled pattern.

  PCRE_ERROR_NOMEMORY       (-6)

If a pattern contains back references, but the \fIovector\fR that is passed to
\fBpcre_exec()\fR is not big enough to remember the referenced substrings, PCRE
gets a block of memory at the start of matching to use for this purpose. If the
call via \fBpcre_malloc()\fR fails, this error is given. The memory is freed at
the end of matching.

  PCRE_ERROR_NOSUBSTRING    (-7)

This error is used by the \fBpcre_copy_substring()\fR,
\fBpcre_get_substring()\fR, and \fBpcre_get_substring_list()\fR functions (see
below). It is never returned by \fBpcre_exec()\fR.

  PCRE_ERROR_MATCHLIMIT     (-8)

The recursion and backtracking limit, as specified by the \fImatch_limit\fR
field in a \fBpcre_extra\fR structure (or defaulted) was reached. See the
description above.

  PCRE_ERROR_CALLOUT        (-9)

This error is never generated by \fBpcre_exec()\fR itself. It is provided for
use by callout functions that want to yield a distinctive error code. See the
\fBpcrecallout\fR documentation for details.

  PCRE_ERROR_BADUTF8        (-10)

A string that contains an invalid UTF-8 byte sequence was passed as a subject.

  PCRE_ERROR_BADUTF8_OFFSET (-11)

The UTF-8 byte sequence that was passed as a subject was valid, but the value
of \fIstartoffset\fR did not point to the beginning of a UTF-8 character.

.SH EXTRACTING CAPTURED SUBSTRINGS BY NUMBER
.rs
.sp
.B int pcre_copy_substring(const char *\fIsubject\fR, int *\fIovector\fR,
.ti +5n
.B int \fIstringcount\fR, int \fIstringnumber\fR, char *\fIbuffer\fR,
.ti +5n
.B int \fIbuffersize\fR);
.PP
.br
.B int pcre_get_substring(const char *\fIsubject\fR, int *\fIovector\fR,
.ti +5n
.B int \fIstringcount\fR, int \fIstringnumber\fR,
.ti +5n
.B const char **\fIstringptr\fR);
.PP
.br
.B int pcre_get_substring_list(const char *\fIsubject\fR,
.ti +5n
.B int *\fIovector\fR, int \fIstringcount\fR, "const char ***\fIlistptr\fR);"
.PP
Captured substrings can be accessed directly by using the offsets returned by
\fBpcre_exec()\fR in \fIovector\fR. For convenience, the functions
\fBpcre_copy_substring()\fR, \fBpcre_get_substring()\fR, and
\fBpcre_get_substring_list()\fR are provided for extracting captured substrings
as new, separate, zero-terminated strings. These functions identify substrings
by number. The next section describes functions for extracting named
substrings. A substring that contains a binary zero is correctly extracted and
has a further zero added on the end, but the result is not, of course,
a C string.

The first three arguments are the same for all three of these functions:
\fIsubject\fR is the subject string which has just been successfully matched,
\fIovector\fR is a pointer to the vector of integer offsets that was passed to
\fBpcre_exec()\fR, and \fIstringcount\fR is the number of substrings that were
captured by the match, including the substring that matched the entire regular
expression. This is the value returned by \fBpcre_exec\fR if it is greater than
zero. If \fBpcre_exec()\fR returned zero, indicating that it ran out of space
in \fIovector\fR, the value passed as \fIstringcount\fR should be the size of
the vector divided by three.

The functions \fBpcre_copy_substring()\fR and \fBpcre_get_substring()\fR
extract a single substring, whose number is given as \fIstringnumber\fR. A
value of zero extracts the substring that matched the entire pattern, while
higher values extract the captured substrings. For \fBpcre_copy_substring()\fR,
the string is placed in \fIbuffer\fR, whose length is given by
\fIbuffersize\fR, while for \fBpcre_get_substring()\fR a new block of memory is
obtained via \fBpcre_malloc\fR, and its address is returned via
\fIstringptr\fR. The yield of the function is the length of the string, not
including the terminating zero, or one of

  PCRE_ERROR_NOMEMORY       (-6)

The buffer was too small for \fBpcre_copy_substring()\fR, or the attempt to get
memory failed for \fBpcre_get_substring()\fR.

  PCRE_ERROR_NOSUBSTRING    (-7)

There is no substring whose number is \fIstringnumber\fR.

The \fBpcre_get_substring_list()\fR function extracts all available substrings
and builds a list of pointers to them. All this is done in a single block of
memory which is obtained via \fBpcre_malloc\fR. The address of the memory block
is returned via \fIlistptr\fR, which is also the start of the list of string
pointers. The end of the list is marked by a NULL pointer. The yield of the
function is zero if all went well, or

  PCRE_ERROR_NOMEMORY       (-6)

if the attempt to get the memory block failed.

When any of these functions encounter a substring that is unset, which can
happen when capturing subpattern number \fIn+1\fR matches some part of the
subject, but subpattern \fIn\fR has not been used at all, they return an empty
string. This can be distinguished from a genuine zero-length substring by
inspecting the appropriate offset in \fIovector\fR, which is negative for unset
substrings.

The two convenience functions \fBpcre_free_substring()\fR and
\fBpcre_free_substring_list()\fR can be used to free the memory returned by
a previous call of \fBpcre_get_substring()\fR or
\fBpcre_get_substring_list()\fR, respectively. They do nothing more than call
the function pointed to by \fBpcre_free\fR, which of course could be called
directly from a C program. However, PCRE is used in some situations where it is
linked via a special interface to another programming language which cannot use
\fBpcre_free\fR directly; it is for these cases that the functions are
provided.

.SH EXTRACTING CAPTURED SUBSTRINGS BY NAME
.rs
.sp
.B int pcre_copy_named_substring(const pcre *\fIcode\fR,
.ti +5n
.B const char *\fIsubject\fR, int *\fIovector\fR,
.ti +5n
.B int \fIstringcount\fR, const char *\fIstringname\fR,
.ti +5n
.B char *\fIbuffer\fR, int \fIbuffersize\fR);
.PP
.br
.B int pcre_get_stringnumber(const pcre *\fIcode\fR,
.ti +5n
.B const char *\fIname\fR);
.PP
.br
.B int pcre_get_named_substring(const pcre *\fIcode\fR,
.ti +5n
.B const char *\fIsubject\fR, int *\fIovector\fR,
.ti +5n
.B int \fIstringcount\fR, const char *\fIstringname\fR,
.ti +5n
.B const char **\fIstringptr\fR);
.PP
To extract a substring by name, you first have to find associated number. This
can be done by calling \fBpcre_get_stringnumber()\fR. The first argument is the
compiled pattern, and the second is the name. For example, for this pattern

  ab(?<xxx>\\d+)...

the number of the subpattern called "xxx" is 1. Given the number, you can then
extract the substring directly, or use one of the functions described in the
previous section. For convenience, there are also two functions that do the
whole job.

Most of the arguments of \fIpcre_copy_named_substring()\fR and
\fIpcre_get_named_substring()\fR are the same as those for the functions that
extract by number, and so are not re-described here. There are just two
differences.

First, instead of a substring number, a substring name is given. Second, there
is an extra argument, given at the start, which is a pointer to the compiled
pattern. This is needed in order to gain access to the name-to-number
translation table.

These functions call \fBpcre_get_stringnumber()\fR, and if it succeeds, they
then call \fIpcre_copy_substring()\fR or \fIpcre_get_substring()\fR, as
appropriate.

.in 0
Last updated: 09 December 2003
.br
Copyright (c) 1997-2003 University of Cambridge.
